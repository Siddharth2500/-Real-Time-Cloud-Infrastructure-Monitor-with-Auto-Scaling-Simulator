# -*- coding: utf-8 -*-
"""Real-Time Cloud Infrastructure Monitor with Auto-Scaling Simulator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y1sEyvWd3UiDWmKNrdVAn4E3hqiXSSDK
"""

"""
Real-Time Cloud Infrastructure Monitor with Auto-Scaling Simulator
Author: DevOps Engineer
Description: Monitors cloud resources, simulates auto-scaling, and provides real-time metrics
"""

import time
import random
import threading
import json
from datetime import datetime
from collections import deque
import matplotlib.pyplot as plt
import pandas as pd

class CloudResource:
    """Simulates a cloud resource (EC2, container, etc.)"""
    def __init__(self, resource_id, resource_type):
        self.id = resource_id
        self.type = resource_type
        self.cpu_usage = random.uniform(20, 40)
        self.memory_usage = random.uniform(30, 50)
        self.network_io = random.uniform(100, 500)
        self.status = "running"
        self.created_at = datetime.now()

    def update_metrics(self):
        """Simulate resource metric updates"""
        self.cpu_usage = max(0, min(100, self.cpu_usage + random.uniform(-10, 15)))
        self.memory_usage = max(0, min(100, self.memory_usage + random.uniform(-5, 10)))
        self.network_io = max(0, random.uniform(0, 1000))

    def to_dict(self):
        return {
            'id': self.id,
            'type': self.type,
            'cpu': round(self.cpu_usage, 2),
            'memory': round(self.memory_usage, 2),
            'network': round(self.network_io, 2),
            'status': self.status
        }

class AutoScaler:
    """Implements auto-scaling logic"""
    def __init__(self, min_instances=2, max_instances=10, scale_up_threshold=70, scale_down_threshold=30):
        self.min_instances = min_instances
        self.max_instances = max_instances
        self.scale_up_threshold = scale_up_threshold
        self.scale_down_threshold = scale_down_threshold

    def should_scale_up(self, avg_cpu):
        return avg_cpu > self.scale_up_threshold

    def should_scale_down(self, avg_cpu):
        return avg_cpu < self.scale_down_threshold

class CloudInfrastructureMonitor:
    """Main monitoring and auto-scaling system"""
    def __init__(self):
        self.resources = []
        self.metrics_history = {
            'timestamp': deque(maxlen=50),
            'avg_cpu': deque(maxlen=50),
            'avg_memory': deque(maxlen=50),
            'total_network': deque(maxlen=50),
            'instance_count': deque(maxlen=50)
        }
        self.autoscaler = AutoScaler()
        self.monitoring = False
        self.alert_log = []

        for i in range(self.autoscaler.min_instances):
            self.add_resource(f"instance-{i}", "EC2")

    def add_resource(self, resource_id, resource_type):
        """Add a new cloud resource"""
        resource = CloudResource(resource_id, resource_type)
        self.resources.append(resource)
        self.log_alert(f"‚úÖ Added resource: {resource_id}", "INFO")

    def remove_resource(self):
        """Remove a cloud resource"""
        if len(self.resources) > self.autoscaler.min_instances:
            resource = self.resources.pop()
            self.log_alert(f"‚ùå Removed resource: {resource.id}", "INFO")

    def log_alert(self, message, level="INFO"):
        """Log alerts and events"""
        alert = {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'level': level,
            'message': message
        }
        self.alert_log.append(alert)
        print(f"[{alert['timestamp']}] {level}: {message}")

    def collect_metrics(self):
        """Collect metrics from all resources"""
        if not self.resources:
            return

        for resource in self.resources:
            resource.update_metrics()

        avg_cpu = sum(r.cpu_usage for r in self.resources) / len(self.resources)
        avg_memory = sum(r.memory_usage for r in self.resources) / len(self.resources)
        total_network = sum(r.network_io for r in self.resources)

        timestamp = datetime.now().strftime('%H:%M:%S')
        self.metrics_history['timestamp'].append(timestamp)
        self.metrics_history['avg_cpu'].append(avg_cpu)
        self.metrics_history['avg_memory'].append(avg_memory)
        self.metrics_history['total_network'].append(total_network)
        self.metrics_history['instance_count'].append(len(self.resources))

        if avg_cpu > 80:
            self.log_alert(f"‚ö†Ô∏è High CPU usage: {avg_cpu:.2f}%", "WARNING")
        if avg_memory > 85:
            self.log_alert(f"‚ö†Ô∏è High Memory usage: {avg_memory:.2f}%", "WARNING")

        return avg_cpu, avg_memory, total_network

    def auto_scale(self):
        """Execute auto-scaling logic"""
        if not self.resources:
            return

        avg_cpu = sum(r.cpu_usage for r in self.resources) / len(self.resources)

        if self.autoscaler.should_scale_up(avg_cpu) and len(self.resources) < self.autoscaler.max_instances:
            new_id = f"instance-{len(self.resources)}"
            self.add_resource(new_id, "EC2")
            self.log_alert(f"üöÄ Scaled UP: Added {new_id} (CPU: {avg_cpu:.2f}%)", "SCALING")

        elif self.autoscaler.should_scale_down(avg_cpu) and len(self.resources) > self.autoscaler.min_instances:
            self.remove_resource()
            self.log_alert(f"üîΩ Scaled DOWN: Removed instance (CPU: {avg_cpu:.2f}%)", "SCALING")

    def monitor_loop(self, duration=60, interval=2):
        """Main monitoring loop"""
        self.monitoring = True
        print(f"\n{'='*60}")
        print("üå©Ô∏è  CLOUD INFRASTRUCTURE MONITORING STARTED")
        print(f"{'='*60}\n")

        start_time = time.time()
        while self.monitoring and (time.time() - start_time) < duration:
            self.collect_metrics()
            self.auto_scale()
            time.sleep(interval)

        self.monitoring = False
        print(f"\n{'='*60}")
        print("üõë MONITORING STOPPED")
        print(f"{'='*60}\n")

    def generate_report(self):
        """Generate monitoring report"""
        if not self.metrics_history['timestamp']:
            print("No metrics collected yet.")
            return

        print("\n" + "="*60)
        print("üìä INFRASTRUCTURE MONITORING REPORT")
        print("="*60)

        print("\nüîç Current Status:")
        print(f"  Active Instances: {len(self.resources)}")
        print(f"  Average CPU: {self.metrics_history['avg_cpu'][-1]:.2f}%")
        print(f"  Average Memory: {self.metrics_history['avg_memory'][-1]:.2f}%")
        print(f"  Total Network I/O: {self.metrics_history['total_network'][-1]:.2f} MB/s")

        print("\nüìà Statistics:")
        print(f"  Max CPU: {max(self.metrics_history['avg_cpu']):.2f}%")
        print(f"  Min CPU: {min(self.metrics_history['avg_cpu']):.2f}%")
        print(f"  Max Instances: {max(self.metrics_history['instance_count'])}")
        print(f"  Min Instances: {min(self.metrics_history['instance_count'])}")

        print("\n‚ö†Ô∏è  Recent Alerts (Last 5):")
        for alert in self.alert_log[-5:]:
            print(f"  [{alert['timestamp']}] {alert['level']}: {alert['message']}")

        print("\nüíª Resource Details:")
        for resource in self.resources:
            print(f"  {resource.id}: CPU={resource.cpu_usage:.1f}% | Memory={resource.memory_usage:.1f}% | Status={resource.status}")

        print("\n" + "="*60 + "\n")

    def plot_metrics(self):
        """Plot metrics visualization"""
        if not self.metrics_history['timestamp']:
            print("No metrics to plot.")
            return

        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle('Cloud Infrastructure Metrics Dashboard', fontsize=16, fontweight='bold')

        timestamps = list(self.metrics_history['timestamp'])
        x_indices = range(len(timestamps))

        axes[0, 0].plot(x_indices, list(self.metrics_history['avg_cpu']), 'b-', linewidth=2)
        axes[0, 0].axhline(y=self.autoscaler.scale_up_threshold, color='r', linestyle='--', label='Scale Up Threshold')
        axes[0, 0].axhline(y=self.autoscaler.scale_down_threshold, color='g', linestyle='--', label='Scale Down Threshold')
        axes[0, 0].set_title('Average CPU Usage (%)')
        axes[0, 0].set_xlabel('Time')
        axes[0, 0].set_ylabel('CPU %')
        axes[0, 0].legend()
        axes[0, 0].grid(True, alpha=0.3)

        axes[0, 1].plot(x_indices, list(self.metrics_history['avg_memory']), 'g-', linewidth=2)
        axes[0, 1].set_title('Average Memory Usage (%)')
        axes[0, 1].set_xlabel('Time')
        axes[0, 1].set_ylabel('Memory %')
        axes[0, 1].grid(True, alpha=0.3)

        axes[1, 0].plot(x_indices, list(self.metrics_history['total_network']), 'm-', linewidth=2)
        axes[1, 0].set_title('Total Network I/O (MB/s)')
        axes[1, 0].set_xlabel('Time')
        axes[1, 0].set_ylabel('MB/s')
        axes[1, 0].grid(True, alpha=0.3)

        axes[1, 1].plot(x_indices, list(self.metrics_history['instance_count']), 'r-', linewidth=2, marker='o')
        axes[1, 1].set_title('Active Instance Count')
        axes[1, 1].set_xlabel('Time')
        axes[1, 1].set_ylabel('Instances')
        axes[1, 1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.savefig('cloud_metrics_dashboard.png', dpi=300, bbox_inches='tight')
        print("üìä Dashboard saved as 'cloud_metrics_dashboard.png'")
        plt.show()

    def export_metrics_csv(self, filename='cloud_metrics.csv'):
        """Export metrics to CSV"""
        df = pd.DataFrame({
            'Timestamp': list(self.metrics_history['timestamp']),
            'Avg_CPU': list(self.metrics_history['avg_cpu']),
            'Avg_Memory': list(self.metrics_history['avg_memory']),
            'Total_Network_IO': list(self.metrics_history['total_network']),
            'Instance_Count': list(self.metrics_history['instance_count'])
        })
        df.to_csv(filename, index=False)
        print(f"üìÅ Metrics exported to '{filename}'")

# Main execution
if __name__ == "__main__":
    monitor = CloudInfrastructureMonitor()

    print("üöÄ Starting Cloud Infrastructure Monitor...")
    print("‚è±Ô∏è  Monitoring duration: 30 seconds")
    print("üìä Collecting metrics every 2 seconds")
    print("üîÑ Auto-scaling enabled\n")

    monitor.monitor_loop(duration=30, interval=2)
    monitor.generate_report()
    monitor.plot_metrics()
    monitor.export_metrics_csv()

    print("\n‚úÖ Monitoring completed successfully!")
    print("üì¶ Files generated:")
    print("   - cloud_metrics_dashboard.png")
    print("   - cloud_metrics.csv")